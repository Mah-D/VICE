package aeneas.jvm;

import java.text.CharacterIterator;
import java.text.StringCharacterIterator;
import java.util.List;
import java.util.LinkedList;
import java.io.*;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

/**
 * This class implements a test driver that executes Virgil test programs with
 * their specified inputs, checking them against their specified outputs. This
 * allows the code generated by Aeneas to run on the JVM to be tested on the JVM.
 */
public class JVMTester {

    private static class Run {
        final Object[] inputs;
        final Object result;
        final Class exception;

        Run(Object[] inputs, Object result, Class exception) {
            this.inputs = inputs;
            this.result = result;
            this.exception = exception;
        }

        String expected() {
            if (exception != null) {
                return "!" + exception.getName();
            }
            return result.toString();
        }
    }

    public static void main(String[] args) throws Exception {
        ProgressPrinter progress = new ProgressPrinter(args.length, 1);
        for (String fname : args) {
            runTest(fname, progress);
        }
        progress.report();
    }

    private static void runTest(String fname, ProgressPrinter progress) {
        try {
            progress.begin(fname);
            File file = new File(fname);
            BufferedReader is = new BufferedReader(new FileReader(file));
            List<Run> runs = parseSpecLine(new StringCharacterIterator(is.readLine()));
            is.close();
            runTests(V3Runner.findVirgilEntrypoint(V3Runner.getJavaClassName(file.getName())), runs);
            progress.pass();
        } catch (Throwable t) {
            progress.fail(t.toString());
        }
    }

    private static void runTests(Method testMethod, List<Run> runs) throws Exception {
        testMethod.setAccessible(true);
        int num = 1;
        for (Run run : runs) {
            try {
                Object result = testMethod.invoke(null, run.inputs);
                if (run.result == null || !run.result.equals(result)) {
                    throw new Exception("run #" + num + " failed with " + result + ", expected " + run.expected());
                }
            } catch (InvocationTargetException e) {
                Throwable r = e.getCause();
                if (r.getClass() != run.exception)
                    throw new Exception("run #" + num + " failed with !" + r.getClass().getName() + " (" + r.getMessage() + "), expected " + run.expected());
            }
            num++;
        }
    }

    private static Class getJavaException(String name) throws Exception {
        if ("NullCheckException".equals(name)) return NullPointerException.class;
        if ("DivideByZeroException".equals(name)) return ArithmeticException.class;
        if ("BoundsCheckException".equals(name)) return ArrayIndexOutOfBoundsException.class;
        if ("TypeCheckException".equals(name)) return ClassCastException.class;
        if ("UnimplementedException".equals(name)) return AbstractMethodError.class;
        if ("ArrayAllocationException".equals(name)) return NegativeArraySizeException.class;
        throw new Exception("Unknown exception class " + name);
    }

    public static List<Run> parseSpecLine(CharacterIterator iter) throws Exception {
        List<Run> list = new LinkedList<Run>();
        skipWhiteSpace(iter);
        expect(iter, "//@execute");
        skipWhiteSpace(iter);

        if (option(iter, '=')) {
            // a single run.
            skipWhiteSpace(iter);
            list.add(parseResult(iter, new Object[0]));
        } else {
            // multiple runs.
            do {
                skipWhiteSpace(iter);
                list.add(parseRun(iter));
                skipWhiteSpace(iter);
            } while (option(iter, ';'));
        }

        return list;
    }

    private static Run parseRun(CharacterIterator iter) throws Exception {
        Object[] inputs;
        if (option(iter, '(')) {
            inputs = parseValues(iter);
        } else {
            inputs = new Object[] { parseValue(iter) };
        }
        skipWhiteSpace(iter);
        expect(iter, '=');
        skipWhiteSpace(iter);
        return parseResult(iter, inputs);
    }

    private static Object[] parseValues(CharacterIterator iter) throws Exception {
        List<Object> input = new LinkedList<Object>();
        while (iter.current() != CharacterIterator.DONE) {
            skipWhiteSpace(iter);
            input.add(parseValue(iter));
            skipWhiteSpace(iter);
            if (option(iter, ')')) break;
            else expect(iter, ',');
        }
        return input.toArray();
    }

    private static Run parseResult(CharacterIterator iter, Object[] input) throws Exception {
        if (iter.current() == '!') {
            iter.next();
            return new Run(input, new Object(), parseException(iter));
        } else {
            Object result = parseValue(iter);
            return new Run(input, result, null);
        }
    }

    public static Object parseValue(CharacterIterator iter) throws Exception {
        switch (iter.current()) {
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9': return parseInt(iter);
            case '\'': return parseChar(iter);
            case 't': expect(iter, "true"); return Boolean.TRUE;
            case 'f': expect(iter, "false"); return Boolean.FALSE;
        }
        throw parseError(iter, "invalid value");
    }

    public static void skipWhiteSpace(CharacterIterator i) {
        while (true) {
            char c = i.current();
            if (c != ' ' && c != '\n' && c != '\t') break;
            i.next();
        }
    }
    public static void expect(CharacterIterator i, char c) throws Exception {
        char r = i.current();
        if (r != c) parseError(i, "expected character \'" + c + "\'");
        i.next();
    }

    public static void expect(CharacterIterator iter, String s) throws Exception {
        for (int i = 0; i < s.length(); i++) expect(iter, s.charAt(i));
    }

    public static boolean option(CharacterIterator i, char c) {
        char r = i.current();
        if (r == c) {
            i.next();
            return true;
        }
        return false;
    }

    private static Integer parseInt(CharacterIterator iter) throws Exception {
        StringBuffer buf = new StringBuffer();

        if (option(iter, '-')) buf.append('-');

        for (int cntr = 0; cntr < 10; cntr++) {
            char c = iter.current();

            if (!Character.isDigit(c)) break;

            buf.append(c);
            iter.next();
        }

        try {
            return Integer.parseInt(buf.toString());
        } catch (NumberFormatException e) {
            throw parseError(iter, "invalid integer");
        }
    }

    private static Byte parseChar(CharacterIterator iter) throws Exception {
        char next = iter.next();
        if (next == '\\') {
            next = iter.next();
            switch (next) {
                case '\'': next = '\''; break;
                case '\"': next = '\"'; break;
                case '\\': next = '\\'; break;
                case 'b': next = '\b'; break;
                case 'n': next = '\n'; break;
                case 'r': next = '\r'; break;
                case 't': next = '\t'; break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7': {
                    StringBuffer buffer = new StringBuffer();
                    while (Character.isDigit(iter.current())) {
                        buffer.append(iter.current());
                        iter.next();
                    }
                    return (byte) Integer.parseInt(buffer.toString(), 8);
                }
                default: throw parseError(iter, "invalid escaped character");
            }
        }
        iter.next();
        expect(iter, '\'');
        return (byte) next;
    }

    private static Class parseException(CharacterIterator iter) throws Exception {
        StringBuffer buf = new StringBuffer();
        while (iter.current() != CharacterIterator.DONE) {
            char c = iter.current();

            if (!Character.isLetter(c)) break;

            buf.append(c);
            iter.next();
        }
        return getJavaException(buf.toString());
    }

    private static Exception parseError(CharacterIterator iter, String msg) throws Exception {
        StringBuffer buffer = new StringBuffer("Parse error: "+ msg + "\n");
        int max = iter.getEndIndex();
        int pos = iter.getIndex();
        iter.first();
        for (int i = iter.getBeginIndex(); i < max; i++) {
            buffer.append(iter.current());
            iter.next();
        }
        buffer.append("\n");
        for (int i = iter.getBeginIndex(); i < pos; i++) {
            buffer.append(' ');
        }
        buffer.append("^\n");
        throw new Exception(buffer.toString());
    }
}
