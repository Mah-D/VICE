/* Generated By:JavaCC: Do not edit this line. Virgil3Parser.java */
package vpc.vst.parser.v3;

import cck.parser.SimpleCharStream;
import vpc.vst.tree.*;
import vpc.core.types.*;
import vpc.core.ProgramDecl;

import java.util.List;
import java.util.LinkedList;
import java.util.Enumeration;
import java.util.Vector;
import java.io.InputStream;

import vpc.core.base.*;

public class Virgil3Parser implements Virgil3ParserConstants {

    public static VSTModule parseModule(InputStream fis, String fname, TypeEnv te) throws ParseException {
        VSTModule m = new VSTModule(fname, te);
        SimpleCharStream stream = new SimpleCharStream(fis, 1, 1);
        Virgil3Parser parser = new Virgil3Parser(new FileMarkingTokenManager(stream, m.name));
        parser.Module(m);
        return m;
    }

    public static VSTTypeRef newTypeRef(Token tok) {
        return new VSTTypeRef(tok, null, null);
    }

    public static VSTTypeRef newParamTypeRef(Token tok, List<VSTTypeRef> list) {
        return new VSTTypeRef(tok, null, list);
    }

    public static VSTTypeRef newTupleTypeRef(Token tok, List<VSTTypeRef> list) {
        return new VSTTypeRef(tok, Tuple.TYPECON, list);
    }

    public static VSTTypeRef newFuncTypeRef(VSTTypeRef left, Token tok, VSTTypeRef right) {
        List<VSTTypeRef> nl = new LinkedList<VSTTypeRef>();
        nl.add(left);
        nl.add(right);
        return new VSTTypeRef(tok, Function.TYPECON, nl);
    }

    public static VSTTypeRef newAsscTypeRef(VSTTypeRef left, Token tok, VSTTypeRef right) {
        List<VSTTypeRef> nl = new LinkedList<VSTTypeRef>();
        nl.add(left);
        nl.add(right);
        return new VSTTypeRef(tok, Association.TYPECON, nl);
    }

    public static VSTTypeRef newVoidTypeRef(Token tok) {
        return new VSTTypeRef(tok, PrimVoid.TYPECON, null);
    }

    private void addTypeParam(Token tok, TypeEnv nenv, List<TypeParam> tpl) {
        TypeParam tp = new TypeParam(tok);
        tpl.add(tp);
    }

    public final void Module(VSTModule m) throws ParseException {
        VSTTypeDecl decl;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_PROGRAM:
                ProgramDecl(m);
                break;
            default:
                jj_la1[0] = jj_gen;
        }
        label_1:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case KW_CLASS:
                case KW_COMPONENT:
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    break label_1;
            }
            decl = TypeDecl(m);
            m.addTypeDecl(decl);
        }
        jj_consume_token(0);
    }

    public final void ProgramDecl(VSTModule m) throws ParseException {
        Token n;
        ProgramDecl pd;
        jj_consume_token(KW_PROGRAM);
        n = jj_consume_token(IDENTIFIER);
        m.programDecl = pd = new ProgramDecl(n);
        jj_consume_token(TK_LBRACE);
        label_2:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case KW_ENTRYPOINT:
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_2;
            }
            ProgramMember(pd);
        }
        jj_consume_token(TK_RBRACE);
    }

    public final void ProgramMember(ProgramDecl pd) throws ParseException {
        EntryPoint(pd);
    }

    public final void EntryPoint(ProgramDecl pd) throws ParseException {
        Token n, w, m;
        jj_consume_token(KW_ENTRYPOINT);
        n = EntryPointName();
        jj_consume_token(TK_ASSIGN);
        w = jj_consume_token(IDENTIFIER);
        jj_consume_token(TK_DOT);
        m = jj_consume_token(IDENTIFIER);
        jj_consume_token(TK_SEMI);
        pd.addEntryPoint(new ProgramDecl.EntryPoint(n, w, m));
    }

    public final Token EntryPointName() throws ParseException {
        Token n;
        n = jj_consume_token(IDENTIFIER);
        return n;

    }

    public final VSTTypeDecl TypeDecl(VSTModule m) throws ParseException {
        VSTTypeDecl decl;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_CLASS:
                decl = ClassDecl(m);
                jj_consume_token(TK_LBRACE);
                label_3:
                while (true) {
                    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                        case KW_FIELD:
                        case KW_METHOD:
                        case KW_NEW:
                        case KW_PRIVATE:
                        case KW_VALUE:
                            break;
                        default:
                            jj_la1[3] = jj_gen;
                            break label_3;
                    }
                    Member(decl);
                }
                jj_consume_token(TK_RBRACE);
                break;
            case KW_COMPONENT:
                decl = ComponentDecl(m);
                jj_consume_token(TK_LBRACE);
                label_4:
                while (true) {
                    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                        case KW_FIELD:
                        case KW_METHOD:
                        case KW_NEW:
                        case KW_PRIVATE:
                        case KW_VALUE:
                            break;
                        default:
                            jj_la1[4] = jj_gen;
                            break label_4;
                    }
                    Member(decl);
                }
                jj_consume_token(TK_RBRACE);
                break;
            default:
                jj_la1[5] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return decl;

    }

    public final VSTClassDecl ClassDecl(VSTModule m) throws ParseException {
        Token tok;
        VSTTypeRef parent = null;
        TypeEnv cenv = new TypeEnv(m.typeEnv);
        List<TypeParam> tpl = null;
        jj_consume_token(KW_CLASS);
        tok = jj_consume_token(IDENTIFIER);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LT:
                tpl = TypeParamDecl(cenv);
                break;
            default:
                jj_la1[6] = jj_gen;
        }
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_EXTENDS:
                jj_consume_token(KW_EXTENDS);
                parent = TypeRef();
                break;
            default:
                jj_la1[7] = jj_gen;
        }
        return new VSTClassDecl(m, tok, tpl, cenv, parent);

    }

    public final List<TypeParam> TypeParamDecl(TypeEnv env) throws ParseException {
        List<TypeParam> tpl = new LinkedList<TypeParam>();
        jj_consume_token(TK_LT);
        TypeParam(env, tpl);
        label_5:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COMMA:
                    break;
                default:
                    jj_la1[8] = jj_gen;
                    break label_5;
            }
            jj_consume_token(TK_COMMA);
            TypeParam(env, tpl);
        }
        jj_consume_token(TK_GT);
        return tpl;

    }

    public final void TypeParam(TypeEnv nenv, List<TypeParam> tp) throws ParseException {
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        addTypeParam(tok, nenv, tp);
    }

    public final VSTComponentDecl ComponentDecl(VSTModule m) throws ParseException {
        Token tok;
        jj_consume_token(KW_COMPONENT);
        tok = jj_consume_token(IDENTIFIER);
        return new VSTComponentDecl(m, tok, new TypeEnv(m.typeEnv));

    }

    public final void Member(VSTTypeDecl decl) throws ParseException {
        List<VSTModifier> l;
        l = Modifiers();
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_METHOD:
                MethodDecl(decl, l);
                break;
            case KW_FIELD:
                FieldDecl(decl, l);
                break;
            case KW_VALUE:
                ValueDecl(decl, l);
                break;
            case KW_NEW:
                ConstructorDecl(decl, l);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    public final void MethodDecl(VSTTypeDecl decl, List<VSTModifier> l) throws ParseException {
        VSTTypeRef ret;
        Token tok;
        VSTMethodDecl m;
        VSTBlock b;
        List<VSTParamDecl> p;
        List<TypeParam> tpl = null;
        TypeEnv menv = new TypeEnv(decl.typeEnv);
        jj_consume_token(KW_METHOD);
        tok = jj_consume_token(IDENTIFIER);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LT:
                tpl = TypeParamDecl(menv);
                break;
            default:
                jj_la1[10] = jj_gen;
        }
        p = Formals();
        ret = newVoidTypeRef(tok);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_ARROW:
                jj_consume_token(TK_ARROW);
                ret = TypeRef();
                break;
            default:
                jj_la1[11] = jj_gen;
        }
        b = MethodBody();
        m = new VSTMethodDecl(tok, l, tpl, menv, p, ret);
        m.setBlock(b);
        decl.addMethodDecl(m);
    }

    public final List<VSTModifier> Modifiers() throws ParseException {
        Token tok;
        List<VSTModifier> l = null;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_PRIVATE:
                tok = jj_consume_token(KW_PRIVATE);
                l = new LinkedList<VSTModifier>();
                l.add(new VSTModifier(tok));
                break;
            default:
                jj_la1[12] = jj_gen;
        }
        return l;

    }

    public final void FieldDecl(VSTTypeDecl decl, List<VSTModifier> l) throws ParseException {
        jj_consume_token(KW_FIELD);
        SingleFieldDecl(decl, false, l);
        jj_consume_token(TK_SEMI);
    }

    public final void ValueDecl(VSTTypeDecl decl, List<VSTModifier> l) throws ParseException {
        jj_consume_token(KW_VALUE);
        SingleFieldDecl(decl, true, l);
        jj_consume_token(TK_SEMI);
    }

    public final void ConstructorDecl(VSTTypeDecl decl, List<VSTModifier> l) throws ParseException {
        Token tok;
        VSTConstructorDecl m;
        List<VSTParamDecl> p;
        VSTBlock b;
        VSTSuperClause sc;
        tok = jj_consume_token(KW_NEW);
        p = Params();
        sc = SuperClause();
        b = MethodBody();
        m = new VSTConstructorDecl(tok, sc, p);
        m.setBlock(b);
        decl.addConstructor(m);
    }

    public final VSTSuperClause SuperClause() throws ParseException {
        Token tok;
        VSTSuperClause sc = null;
        VSTTupleExpr args;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_COLON:
                jj_consume_token(TK_COLON);
                tok = jj_consume_token(KW_SUPER);
                args = TupleExpr();
                sc = new VSTSuperClause(tok, args);
                break;
            default:
                jj_la1[13] = jj_gen;
        }
        return sc;

    }

    public final void SingleFieldDecl(VSTTypeDecl decl, boolean isValue, List<VSTModifier> l) throws ParseException {
        Token tok;
        VSTTypeRef tref;
        Token a = null;
        VSTExpr i = null;
        VSTFieldDecl fd;
        tok = jj_consume_token(IDENTIFIER);
        jj_consume_token(TK_COLON);
        tref = TypeRef();
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_ASSIGN:
                a = jj_consume_token(TK_ASSIGN);
                i = Expr();
                break;
            default:
                jj_la1[14] = jj_gen;
        }
        fd = new VSTFieldDecl(tok, isValue, tref, a, i, l);
        decl.addFieldDecl(fd);
        fd.memberType = tref;
    }

    public final List<VSTParamDecl> Params() throws ParseException {
        List<VSTParamDecl> l = new LinkedList<VSTParamDecl>();
        Token pname;
        VSTTypeRef ptype;
        VSTParamDecl p;
        jj_consume_token(TK_LPAREN);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                pname = jj_consume_token(IDENTIFIER);
                ptype = OptionalTypeRef();
                l.add(new VSTParamDecl(pname, ptype));
                label_6:
                while (true) {
                    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                        case TK_COMMA:
                            break;
                        default:
                            jj_la1[15] = jj_gen;
                            break label_6;
                    }
                    jj_consume_token(TK_COMMA);
                    pname = jj_consume_token(IDENTIFIER);
                    ptype = OptionalTypeRef();
                    l.add(new VSTParamDecl(pname, ptype));
                }
                break;
            default:
                jj_la1[16] = jj_gen;
        }
        jj_consume_token(TK_RPAREN);
        return l;

    }

    public final List<VSTParamDecl> Formals() throws ParseException {
        List<VSTParamDecl> l = new LinkedList<VSTParamDecl>();
        Token pname;
        VSTTypeRef ptype;
        VSTParamDecl p;
        jj_consume_token(TK_LPAREN);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                pname = jj_consume_token(IDENTIFIER);
                jj_consume_token(TK_COLON);
                ptype = TypeRef();
                l.add(new VSTParamDecl(pname, ptype));
                label_7:
                while (true) {
                    switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                        case TK_COMMA:
                            break;
                        default:
                            jj_la1[17] = jj_gen;
                            break label_7;
                    }
                    jj_consume_token(TK_COMMA);
                    pname = jj_consume_token(IDENTIFIER);
                    jj_consume_token(TK_COLON);
                    ptype = TypeRef();
                    l.add(new VSTParamDecl(pname, ptype));
                }
                break;
            default:
                jj_la1[18] = jj_gen;
        }
        jj_consume_token(TK_RPAREN);
        return l;

    }

    public final VSTBlock MethodBody() throws ParseException {
        VSTBlock b = null;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_SEMI:
                jj_consume_token(TK_SEMI);
                break;
            case TK_LBRACE:
                b = Block();
                break;
            default:
                jj_la1[19] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return b;

    }

    public final VSTBlock Block() throws ParseException {
        Token tok;
        VSTBlock b;
        tok = jj_consume_token(TK_LBRACE);
        b = new VSTBlock(tok);
        label_8:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_IF:
                case KW_LOCAL:
                case KW_NEW:
                case KW_RETURN:
                case KW_MATCH:
                case KW_THIS:
                case KW_WHILE:
                case KW_FALSE:
                case KW_TRUE:
                case KW_NULL:
                case ZERO_LITERAL:
                case DECIMAL_LITERAL:
                case HEX_LITERAL:
                case BIN_LITERAL:
                case OCTAL_LITERAL:
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case IDENTIFIER:
                case TK_LPAREN:
                case TK_LBRACE:
                case TK_LBRACKET:
                case TK_SEMI:
                case TK_NOT:
                case TK_TYPE_QUERY:
                case TK_TYPE_CAST:
                case TK_MINUS:
                    break;
                default:
                    jj_la1[20] = jj_gen;
                    break label_8;
            }
            BlockStmt(b);
        }
        tok = jj_consume_token(TK_RBRACE);
        b.setLastToken(tok);
        return b;

    }

    public final void BlockStmt(VSTBlock b) throws ParseException {
        VSTStmt s;
        if (jj_2_1(3)) {
            LocalStmt(b);
            jj_consume_token(TK_SEMI);
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case KW_BREAK:
                case KW_CONTINUE:
                case KW_IF:
                case KW_NEW:
                case KW_RETURN:
                case KW_MATCH:
                case KW_THIS:
                case KW_WHILE:
                case KW_FALSE:
                case KW_TRUE:
                case KW_NULL:
                case ZERO_LITERAL:
                case DECIMAL_LITERAL:
                case HEX_LITERAL:
                case BIN_LITERAL:
                case OCTAL_LITERAL:
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case IDENTIFIER:
                case TK_LPAREN:
                case TK_LBRACE:
                case TK_LBRACKET:
                case TK_SEMI:
                case TK_NOT:
                case TK_TYPE_QUERY:
                case TK_TYPE_CAST:
                case TK_MINUS:
                    s = Stmt();
                    b.addStmt(s);
                    break;
                default:
                    jj_la1[21] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
    }

    public final void LocalStmt(VSTBlock b) throws ParseException {
        VSTLocalVarDecl s;
        jj_consume_token(KW_LOCAL);
        s = LocalVarDecl();
        b.addStmt(s);
        label_9:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COMMA:
                    break;
                default:
                    jj_la1[22] = jj_gen;
                    break label_9;
            }
            jj_consume_token(TK_COMMA);
            s = LocalVarDecl();
            b.addStmt(s);
        }
    }

    public final VSTLocalVarDecl LocalVarDecl() throws ParseException {
        Token tok;
        VSTExpr i = null;
        VSTTypeRef tref = null;
        tok = jj_consume_token(IDENTIFIER);
        tref = OptionalTypeRef();
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_ASSIGN:
                jj_consume_token(TK_ASSIGN);
                i = Expr();
                break;
            default:
                jj_la1[23] = jj_gen;
        }
        return new VSTLocalVarDecl(tok, tref, i);

    }

    public final VSTExpr Expr() throws ParseException {
        VSTExpr e, val;
        Token tok;
        e = ConditionalOrExpr();
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_ASSIGN:
                tok = jj_consume_token(TK_ASSIGN);
                val = Expr();
                e = new VSTAssign(tok, e, val);
                break;
            default:
                jj_la1[24] = jj_gen;
        }
        return e;

    }

    public final VSTExpr ConditionalOrExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = ConditionalAndExpr();
        label_10:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COND_OR:
                    break;
                default:
                    jj_la1[25] = jj_gen;
                    break label_10;
            }
            tok = jj_consume_token(TK_COND_OR);
            et = ConditionalAndExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr ConditionalAndExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = InclusiveOrExpr();
        label_11:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COND_AND:
                    break;
                default:
                    jj_la1[26] = jj_gen;
                    break label_11;
            }
            tok = jj_consume_token(TK_COND_AND);
            et = InclusiveOrExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr InclusiveOrExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = ExclusiveOrExpr();
        label_12:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_OR:
                    break;
                default:
                    jj_la1[27] = jj_gen;
                    break label_12;
            }
            tok = jj_consume_token(TK_OR);
            et = ExclusiveOrExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr ExclusiveOrExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = AndExpr();
        label_13:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_XOR:
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    break label_13;
            }
            tok = jj_consume_token(TK_XOR);
            et = AndExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr AndExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = EqualityExpr();
        label_14:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_AND:
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    break label_14;
            }
            tok = jj_consume_token(TK_AND);
            et = EqualityExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr EqualityExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = RelationalExpr();
        label_15:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_EQ:
                    break;
                default:
                    jj_la1[30] = jj_gen;
                    break label_15;
            }
            tok = jj_consume_token(TK_EQ);
            et = RelationalExpr();
            e = new VSTComparison(tok, e, et);
        }
        return e;

    }

    public final VSTExpr RelationalExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = ShiftExpr();
        label_16:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_LT:
                case TK_GT:
                case TK_LTEQ:
                case TK_GTEQ:
                    break;
                default:
                    jj_la1[31] = jj_gen;
                    break label_16;
            }
            tok = RelationalOp();
            et = ShiftExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final Token RelationalOp() throws ParseException {
        Token tok;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LT:
                tok = jj_consume_token(TK_LT);
                break;
            case TK_GT:
                tok = jj_consume_token(TK_GT);
                break;
            case TK_GTEQ:
                tok = jj_consume_token(TK_GTEQ);
                break;
            case TK_LTEQ:
                tok = jj_consume_token(TK_LTEQ);
                break;
            default:
                jj_la1[32] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return tok;

    }

    public final VSTExpr ShiftExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = AdditiveExpr();
        label_17:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_SHL:
                case TK_SHR:
                    break;
                default:
                    jj_la1[33] = jj_gen;
                    break label_17;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_SHL:
                    tok = jj_consume_token(TK_SHL);
                    break;
                case TK_SHR:
                    tok = jj_consume_token(TK_SHR);
                    break;
                default:
                    jj_la1[34] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = AdditiveExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr AdditiveExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = MultiplicativeExpr();
        label_18:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_PLUS:
                case TK_MINUS:
                    break;
                default:
                    jj_la1[35] = jj_gen;
                    break label_18;
            }
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_PLUS:
                    tok = jj_consume_token(TK_PLUS);
                    break;
                case TK_MINUS:
                    tok = jj_consume_token(TK_MINUS);
                    break;
                default:
                    jj_la1[36] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            et = MultiplicativeExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr MultiplicativeExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        e = UnaryExpr();
        label_19:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_MUL:
                    break;
                default:
                    jj_la1[37] = jj_gen;
                    break label_19;
            }
            tok = jj_consume_token(TK_MUL);
            et = UnaryExpr();
            e = new VSTBinOp(tok, e, et);
        }
        return e;

    }

    public final VSTExpr UnaryExpr() throws ParseException {
        VSTExpr e, et;
        Token tok;
        if (jj_2_2(2)) {
            e = NegativeLiteral();
        } else {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_NOT:
                    tok = UnaryOp();
                    et = UnaryExpr();
                    e = new VSTUnaryOp(tok, et);
                    break;
                case TK_TYPE_CAST:
                    e = TypeCastExpr();
                    break;
                case TK_TYPE_QUERY:
                    e = TypeQueryExpr();
                    break;
                case KW_NEW:
                case KW_THIS:
                case KW_FALSE:
                case KW_TRUE:
                case KW_NULL:
                case ZERO_LITERAL:
                case DECIMAL_LITERAL:
                case HEX_LITERAL:
                case BIN_LITERAL:
                case OCTAL_LITERAL:
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case IDENTIFIER:
                case TK_LPAREN:
                case TK_LBRACKET:
                    e = Term();
                    break;
                default:
                    jj_la1[38] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        return e;

    }

    public final VSTExpr NegativeLiteral() throws ParseException {
        Token m, tok;
        m = jj_consume_token(TK_MINUS);
        tok = jj_consume_token(DECIMAL_LITERAL);
        return new VSTIntLiteral(m, tok);

    }

    public final VSTExpr TypeCastExpr() throws ParseException {
        Token tok;
        VSTExpr e;
        VSTTypeRef tref;
        tok = jj_consume_token(TK_TYPE_CAST);
        tref = TypeRef();
        e = UnaryExpr();
        return new VSTTypeCastExpr(tok, e, tref);

    }

    public final VSTExpr TypeQueryExpr() throws ParseException {
        Token tok;
        VSTExpr e;
        VSTTypeRef tref;
        tok = jj_consume_token(TK_TYPE_QUERY);
        tref = TypeRef();
        e = UnaryExpr();
        return new VSTTypeQueryExpr(tok, e, tref);

    }

    public final Token UnaryOp() throws ParseException {
        Token tok;
        tok = jj_consume_token(TK_NOT);
        return tok;

    }

    public final VSTExpr Term() throws ParseException {
        VSTExpr e, et;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_THIS:
            case KW_FALSE:
            case KW_TRUE:
            case KW_NULL:
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case BIN_LITERAL:
            case OCTAL_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case TK_LPAREN:
            case TK_LBRACKET:
                e = TermPrefix();
                break;
            case KW_NEW:
                e = NewExpr();
                break;
            default:
                jj_la1[39] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        label_20:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_LPAREN:
                case TK_DOT:
                    break;
                default:
                    jj_la1[40] = jj_gen;
                    break label_20;
            }
            e = Suffix(e);
        }
        return e;

    }

    public final VSTExpr Suffix(VSTExpr e) throws ParseException {
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_DOT:
                e = MemberSuffix(e);
                break;
            case TK_LPAREN:
                e = AppSuffix(e);
                break;
            default:
                jj_la1[41] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public final VSTExpr TermPrefix() throws ParseException {
        VSTExpr e;
        Token tok;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case IDENTIFIER:
                e = VarUse();
                break;
            case KW_THIS:
            case KW_FALSE:
            case KW_TRUE:
            case KW_NULL:
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case BIN_LITERAL:
            case OCTAL_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
                e = Literal();
                break;
            case TK_LBRACKET:
                e = ArrayExpr();
                break;
            case TK_LPAREN:
                e = TupleExpr();
                break;
            default:
                jj_la1[42] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public final VSTArrayInitializer ArrayExpr() throws ParseException {
        List<VSTExpr> l = new LinkedList<VSTExpr>();
        Token tok;
        tok = jj_consume_token(TK_LBRACKET);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_NEW:
            case KW_THIS:
            case KW_FALSE:
            case KW_TRUE:
            case KW_NULL:
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case BIN_LITERAL:
            case OCTAL_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case TK_LPAREN:
            case TK_LBRACKET:
            case TK_NOT:
            case TK_TYPE_QUERY:
            case TK_TYPE_CAST:
            case TK_MINUS:
                ListExpr(l);
                break;
            default:
                jj_la1[43] = jj_gen;
        }
        jj_consume_token(TK_RBRACKET);
        return new VSTArrayInitializer(tok, l);

    }

    public final VSTTupleExpr TupleExpr() throws ParseException {
        List<VSTExpr> l = new LinkedList<VSTExpr>();
        Token tok;
        tok = jj_consume_token(TK_LPAREN);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_NEW:
            case KW_THIS:
            case KW_FALSE:
            case KW_TRUE:
            case KW_NULL:
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case BIN_LITERAL:
            case OCTAL_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case TK_LPAREN:
            case TK_LBRACKET:
            case TK_NOT:
            case TK_TYPE_QUERY:
            case TK_TYPE_CAST:
            case TK_MINUS:
                ListExpr(l);
                break;
            default:
                jj_la1[44] = jj_gen;
        }
        jj_consume_token(TK_RPAREN);
        return new VSTTupleExpr(tok, l);

    }

    public final VSTExpr VarUse() throws ParseException {
        Token tok;
        tok = jj_consume_token(IDENTIFIER);
        return new VSTVarUse(tok);

    }

    public final VSTExpr Literal() throws ParseException {
        VSTExpr e;
        Token tok;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ZERO_LITERAL:
                tok = jj_consume_token(ZERO_LITERAL);
                e = new VSTIntLiteral(null, tok);
                break;
            case BIN_LITERAL:
                tok = jj_consume_token(BIN_LITERAL);
                e = new VSTRawLiteral(tok);
                break;
            case OCTAL_LITERAL:
                tok = jj_consume_token(OCTAL_LITERAL);
                e = new VSTRawLiteral(tok);
                break;
            case DECIMAL_LITERAL:
                tok = jj_consume_token(DECIMAL_LITERAL);
                e = new VSTIntLiteral(null, tok);
                break;
            case HEX_LITERAL:
                tok = jj_consume_token(HEX_LITERAL);
                e = new VSTRawLiteral(tok);
                break;
            case STRING_LITERAL:
                tok = jj_consume_token(STRING_LITERAL);
                e = new VSTStringLiteral(tok);
                break;
            case CHARACTER_LITERAL:
                tok = jj_consume_token(CHARACTER_LITERAL);
                e = new VSTCharLiteral(tok);
                break;
            case KW_NULL:
                tok = jj_consume_token(KW_NULL);
                e = new VSTNullLiteral(tok);
                break;
            case KW_THIS:
                tok = jj_consume_token(KW_THIS);
                e = new VSTThisLiteral(tok);
                break;
            case KW_TRUE:
                tok = jj_consume_token(KW_TRUE);
                e = new VSTBoolLiteral(tok);
                break;
            case KW_FALSE:
                tok = jj_consume_token(KW_FALSE);
                e = new VSTBoolLiteral(tok);
                break;
            default:
                jj_la1[45] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return e;

    }

    public final VSTExpr NewExpr() throws ParseException {
        Token tok;
        VSTTupleExpr args;
        VSTTypeRef tref;
        tok = jj_consume_token(KW_NEW);
        tref = TypeRef();
        args = TupleExpr();
        return new VSTNewObjectExpr(tok, tref, args);

    }

    public final VSTExpr MemberSuffix(VSTExpr e) throws ParseException {
        Token dot, tok;
        VSTExpr ie;
        dot = jj_consume_token(TK_DOT);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case IDENTIFIER:
                switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                    case IDENTIFIER:
                        tok = jj_consume_token(IDENTIFIER);
                        break;
                    case DECIMAL_LITERAL:
                        tok = jj_consume_token(DECIMAL_LITERAL);
                        break;
                    case ZERO_LITERAL:
                        tok = jj_consume_token(ZERO_LITERAL);
                        break;
                    default:
                        jj_la1[46] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                return new VSTMemberExpr(tok, e);
            case TK_LPAREN:
                ie = TupleExpr();
                return new VSTIndexExpr(dot, e, ie);
            default:
                jj_la1[47] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }

    }

    public final VSTExpr AppSuffix(VSTExpr e) throws ParseException {
        VSTTupleExpr args;
        args = TupleExpr();
        return new VSTAppExpr(e, args);

    }

    public final List<VSTExpr> ListExpr(List<VSTExpr> l) throws ParseException {
        VSTExpr e;
        e = Expr();
        l.add(e);
        label_21:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COMMA:
                    break;
                default:
                    jj_la1[48] = jj_gen;
                    break label_21;
            }
            jj_consume_token(TK_COMMA);
            e = Expr();
            l.add(e);
        }
        return l;

    }

    public final VSTStmt Stmt() throws ParseException {
        VSTStmt s;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LBRACE:
                s = Block();
                break;
            case TK_SEMI:
                s = EmptyStmt();
                break;
            case KW_BREAK:
                s = BreakStmt();
                break;
            case KW_CONTINUE:
                s = ContinueStmt();
                break;
            case KW_RETURN:
                s = ReturnStmt();
                break;
            case KW_WHILE:
                s = WhileStmt();
                break;
            case KW_IF:
                s = IfStmt();
                break;
            case KW_MATCH:
                s = MatchStmt();
                break;
            case KW_NEW:
            case KW_THIS:
            case KW_FALSE:
            case KW_TRUE:
            case KW_NULL:
            case ZERO_LITERAL:
            case DECIMAL_LITERAL:
            case HEX_LITERAL:
            case BIN_LITERAL:
            case OCTAL_LITERAL:
            case CHARACTER_LITERAL:
            case STRING_LITERAL:
            case IDENTIFIER:
            case TK_LPAREN:
            case TK_LBRACKET:
            case TK_NOT:
            case TK_TYPE_QUERY:
            case TK_TYPE_CAST:
            case TK_MINUS:
                s = ExprStmt();
                break;
            default:
                jj_la1[49] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return s;

    }

    public final VSTStmt IfStmt() throws ParseException {
        Token tok;
        VSTStmt st, sf = null;
        VSTExpr c;
        tok = jj_consume_token(KW_IF);
        jj_consume_token(TK_LPAREN);
        c = Expr();
        jj_consume_token(TK_RPAREN);
        st = Stmt();
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_ELSE:
                jj_consume_token(KW_ELSE);
                sf = Stmt();
                break;
            default:
                jj_la1[50] = jj_gen;
        }
        return new VSTIfStmt(tok, c, st, sf);

    }

    public final VSTStmt MatchStmt() throws ParseException {
        Token tok;
        VSTExpr e;
        VSTSwitchStmt ss;
        VSTStmt sf;
        tok = jj_consume_token(KW_MATCH);
        jj_consume_token(TK_LPAREN);
        e = Expr();
        jj_consume_token(TK_RPAREN);
        jj_consume_token(TK_LBRACE);
        ss = new VSTSwitchStmt(tok, e);
        label_22:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case KW_NEW:
                case KW_THIS:
                case KW_FALSE:
                case KW_TRUE:
                case KW_NULL:
                case ZERO_LITERAL:
                case DECIMAL_LITERAL:
                case HEX_LITERAL:
                case BIN_LITERAL:
                case OCTAL_LITERAL:
                case CHARACTER_LITERAL:
                case STRING_LITERAL:
                case IDENTIFIER:
                case TK_LPAREN:
                case TK_LBRACKET:
                case TK_NOT:
                case TK_TYPE_QUERY:
                case TK_TYPE_CAST:
                case TK_MINUS:
                    break;
                default:
                    jj_la1[51] = jj_gen;
                    break label_22;
            }
            MatchCase(ss);
        }
        jj_consume_token(TK_RBRACE);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case KW_ELSE:
                tok = jj_consume_token(KW_ELSE);
                sf = Stmt();
                ss.addDefaultCase(new VSTSwitchCase(tok, null, sf));
                break;
            default:
                jj_la1[52] = jj_gen;
        }
        return ss;

    }

    public final void MatchCase(VSTSwitchStmt ss) throws ParseException {
        Token tok;
        List<VSTExpr> l = new LinkedList<VSTExpr>();
        VSTStmt s;
        ListExpr(l);
        tok = jj_consume_token(TK_COLON);
        s = Stmt();
        ss.addCase(new VSTSwitchCase(tok, l, s));
    }

    public final VSTStmt ExprStmt() throws ParseException {
        VSTExpr e;
        e = Expr();
        jj_consume_token(TK_SEMI);
        return new VSTExprStmt(e.getToken(), e);

    }

    public final VSTStmt EmptyStmt() throws ParseException {
        Token tok;
        tok = jj_consume_token(TK_SEMI);
        return new VSTEmptyStmt(tok);

    }

    public final VSTStmt BreakStmt() throws ParseException {
        Token tok;
        tok = jj_consume_token(KW_BREAK);
        jj_consume_token(TK_SEMI);
        return new VSTBreakStmt(tok);

    }

    public final VSTStmt ContinueStmt() throws ParseException {
        Token tok;
        tok = jj_consume_token(KW_CONTINUE);
        jj_consume_token(TK_SEMI);
        return new VSTContinueStmt(tok);

    }

    public final VSTStmt ReturnStmt() throws ParseException {
        Token tok;
        VSTExpr e = null;
        tok = jj_consume_token(KW_RETURN);
        e = Expr();
        jj_consume_token(TK_SEMI);
        return new VSTReturnStmt(tok, e);

    }

    public final VSTStmt WhileStmt() throws ParseException {
        Token tok;
        VSTExpr e;
        VSTStmt s;
        tok = jj_consume_token(KW_WHILE);
        jj_consume_token(TK_LPAREN);
        e = Expr();
        jj_consume_token(TK_RPAREN);
        s = Stmt();
        return new VSTWhileStmt(tok, e, s);

    }

    public final VSTTypeRef TypeRef() throws ParseException {
        Token tok;
        VSTTypeRef tref;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LPAREN:
                tref = TupleType();
                break;
            case IDENTIFIER:
                tref = ParameterizedType();
                break;
            case DECIMAL_LITERAL:
                tref = RawType();
                break;
            default:
                jj_la1[53] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        label_23:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_ARROW:
                case 78:
                    break;
                default:
                    jj_la1[54] = jj_gen;
                    break label_23;
            }
            tref = TypeRefSuffix(tref);
        }
        return tref;

    }

    public final VSTTypeRef TupleType() throws ParseException {
        List<VSTTypeRef> tlist = new LinkedList<VSTTypeRef>();
        Token tok;
        tok = jj_consume_token(TK_LPAREN);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_RPAREN:
                jj_consume_token(TK_RPAREN);
                return newVoidTypeRef(tok);
            case DECIMAL_LITERAL:
            case IDENTIFIER:
            case TK_LPAREN:
                TypeList(tlist);
                jj_consume_token(TK_RPAREN);
                return newTupleTypeRef(tok, tlist);
            default:
                jj_la1[55] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }

    }

    public final void TypeList(List<VSTTypeRef> l) throws ParseException {
        VSTTypeRef tref;
        tref = TypeRef();
        l.add(tref);
        label_24:
        while (true) {
            switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
                case TK_COMMA:
                    break;
                default:
                    jj_la1[56] = jj_gen;
                    break label_24;
            }
            jj_consume_token(TK_COMMA);
            tref = TypeRef();
            l.add(tref);
        }
    }

    public final VSTTypeRef TypeRefSuffix(VSTTypeRef left) throws ParseException {
        Token tok = null;
        VSTTypeRef right;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_ARROW:
                tok = jj_consume_token(TK_ARROW);
                right = TypeRef();
                left = newFuncTypeRef(left, tok, right);
                break;
            case 78:
                tok = jj_consume_token(78);
                right = TypeRef();
                left = newAsscTypeRef(left, tok, right);
                break;
            default:
                jj_la1[57] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        return left;

    }

    public final VSTTypeRef ParameterizedType() throws ParseException {
        Token tycon;
        List<VSTTypeRef> l = new LinkedList<VSTTypeRef>();
        tycon = jj_consume_token(IDENTIFIER);
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_LT:
                jj_consume_token(TK_LT);
                TypeList(l);
                jj_consume_token(TK_GT);
                return newParamTypeRef(tycon, l);
            default:
                jj_la1[58] = jj_gen;
        }
        return newTypeRef(tycon);

    }

    public final VSTTypeRef RawType() throws ParseException {
        Token tok;
        tok = jj_consume_token(DECIMAL_LITERAL);
        return newTypeRef(tok);

    }

    public final VSTTypeRef OptionalTypeRef() throws ParseException {
        VSTTypeRef tref = null;
        switch (jj_ntk == -1 ? jj_ntk() : jj_ntk) {
            case TK_COLON:
                jj_consume_token(TK_COLON);
                tref = TypeRef();
                break;
            default:
                jj_la1[59] = jj_gen;
        }
        return tref;

    }

    private final boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        }
        catch (LookaheadSuccess ls) {
            return true;
        }
        finally {
            jj_save(0, xla);
        }
    }

    private final boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        }
        catch (LookaheadSuccess ls) {
            return true;
        }
        finally {
            jj_save(1, xla);
        }
    }

    private final boolean jj_3R_29() {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_31()) jj_scanpos = xsp;
        return false;
    }

    private final boolean jj_3_2() {
        return jj_3R_26();
    }

    private final boolean jj_3R_28() {
        return jj_scan_token(TK_COMMA);
    }

    private final boolean jj_3R_25() {
        if (jj_scan_token(KW_LOCAL)) return true;
        if (jj_3R_27()) return true;
        Token xsp;
        while (true) {
            xsp = jj_scanpos;
            if (jj_3R_28()) {
                jj_scanpos = xsp;
                break;
            }
        }
        return false;
    }

    private final boolean jj_3R_26() {
        if (jj_scan_token(TK_MINUS)) return true;
        return jj_scan_token(DECIMAL_LITERAL);
    }

    private final boolean jj_3R_30() {
        return jj_scan_token(TK_ASSIGN);
    }

    private final boolean jj_3R_31() {
        return jj_scan_token(TK_COLON);
    }

    private final boolean jj_3_1() {
        if (jj_3R_25()) return true;
        return jj_scan_token(TK_SEMI);
    }

    private final boolean jj_3R_27() {
        if (jj_scan_token(IDENTIFIER)) return true;
        if (jj_3R_29()) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_30()) jj_scanpos = xsp;
        return false;
    }

    public Virgil3ParserTokenManager token_source;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private int jj_gen;
    private final int[] jj_la1 = new int[60];
    private static int[] jj_la1_0;
    private static int[] jj_la1_1;
    private static int[] jj_la1_2;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[]{0x80000000, 0xc000, 0x0, 0x41c80000, 0x41c80000, 0xc000, 0x0, 0x40000, 0x0, 0x40c80000, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3ab12000, 0x3a912000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10800000, 0x10800000, 0x0, 0x0, 0x10000000, 0x10800000, 0x10800000, 0x10000000, 0x0, 0x0, 0x0, 0x3a912000, 0x20000, 0x10800000, 0x20000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x800000, 0x0, 0x20000000, 0x10000000, 0x0, 0x0, 0x2000000, 0x800000, 0x2000, 0x800000, 0x2000, 0x440000, 0x553ff8, 0x553ff8, 0x800000, 0x2000000, 0x2000000, 0x8000000, 0x4000000, 0x0, 0x0, 0x0, 0x0, 0xe0000000, 0xe0000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x113ff8, 0x113ff8, 0x1010000, 0x1010000, 0x113ff8, 0x113ff8, 0x113ff8, 0x1ff8, 0x20c0, 0x120c0, 0x800000, 0x553ff8, 0x0, 0x113ff8, 0x0, 0x12080, 0x10000000, 0x32080, 0x800000, 0x10000000, 0x20000000, 0x0,};
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x268, 0x268, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1000, 0x2000, 0x800, 0x80, 0x1, 0x1, 0x6, 0x6, 0x300, 0x300, 0x400, 0x68, 0x0, 0x0, 0x0, 0x0, 0x268, 0x268, 0x0, 0x0, 0x0, 0x0, 0x268, 0x0, 0x268, 0x0, 0x0, 0x4000, 0x0, 0x0, 0x4000, 0x0, 0x10,};
    }

    private final JJCalls[] jj_2_rtns = new JJCalls[2];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public Virgil3Parser(Virgil3ParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 60; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private final Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    private static final class LookaheadSuccess extends Error {
    }

    private final LookaheadSuccess jj_ls = new LookaheadSuccess();

    private final boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    private final int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return jj_ntk = (token.next = token_source.getNextToken()).kind;
        else
            return jj_ntk = jj_nt.kind;
    }

    private Vector jj_expentries = new Vector();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[]) e.nextElement();
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[79];
        for (int i = 0; i < 79; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 60; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & 1 << j) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & 1 << j) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & 1 << j) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 79; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private final void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 2; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private final void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
