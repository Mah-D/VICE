/* Generated By:JavaCC: Do not edit this line. VirgilParser.java */
package vpc.vst.parser.v2;

import cck.parser.SimpleCharStream;
import vpc.core.ProgramDecl;
import vpc.core.base.*;
import vpc.core.types.*;
import vpc.core.virgil.VirgilArray;
import vpc.vst.tree.*;

import java.util.LinkedList;
import java.util.List;

public class VirgilParser implements VirgilParserConstants {

    public static VSTModule parseModule(java.io.InputStream fis, String fname, TypeEnv te) throws ParseException {
        VSTModule m = new VSTModule(fname, te);
        SimpleCharStream stream = new SimpleCharStream(fis, 1, 1);
        VirgilParser parser = new VirgilParser(new FileMarkingTokenManager(stream, m.name));
        parser.Module(m);
        return m;
    }

    public static VSTTypeRef newTypeRef(Token tok) {
        return new VSTTypeRef(tok, null, null);
    }

    public static VSTTypeRef newParamTypeRef(Token tok, List<VSTTypeRef> list) {
        return new VSTTypeRef(tok, null, list);
    }

    public static VSTTypeRef newArrayTypeRef(Token tok, VSTTypeRef et) {
        List<VSTTypeRef> nl = new LinkedList<VSTTypeRef>();
        nl.add(et);
        return new VSTTypeRef(tok, VirgilArray.TYPECON, nl);
    }

    public static VSTTypeRef newFuncTypeRef(Token tok, VSTTypeRef rt, List<VSTTypeRef> args) {
        List<VSTTypeRef> nl = new LinkedList<VSTTypeRef>();
        VSTTypeRef pt = new VSTTypeRef(tok, Tuple.TYPECON, args);
        nl.add(pt);
        nl.add(rt);
        return new VSTTypeRef(tok, Function.TYPECON, nl);
    }

    public static VSTTypeRef newVoidRef(Token tok) {
        return new VSTTypeRef(tok, PrimVoid.TYPECON, null);
    }

    private void addTypeParam(Token tok, TypeEnv nenv, List<TypeParam> tpl) {
        TypeParam tp = new TypeParam(tok);
        tpl.add(tp);
    }

  final public void Module(VSTModule m) throws ParseException {
  VSTTypeDecl decl;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_PROGRAM:
      ProgramDecl(m);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_CLASS:
      case KW_COMPONENT:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      decl = TypeDecl(m);
                        m.addTypeDecl(decl);
    }
    jj_consume_token(0);
  }

  final public void ProgramDecl(VSTModule m) throws ParseException {
                                  Token n; ProgramDecl pd;
    jj_consume_token(KW_PROGRAM);
    n = jj_consume_token(IDENTIFIER);
                                 m.programDecl = pd = new ProgramDecl(n);
    jj_consume_token(TK_LBRACE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_ENTRYPOINT:
      case KW_COMPONENTS:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      ProgramMember(pd);
    }
    jj_consume_token(TK_RBRACE);
  }

  final public void ProgramMember(ProgramDecl pd) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_ENTRYPOINT:
      EntryPoint(pd);
      break;
    case KW_COMPONENTS:
      ComponentList(pd);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void EntryPoint(ProgramDecl pd) throws ParseException {
                                    Token n, w, m;
    jj_consume_token(KW_ENTRYPOINT);
    n = EntryPointName();
    jj_consume_token(TK_ASSIGN);
    w = jj_consume_token(IDENTIFIER);
    jj_consume_token(TK_DOT);
    m = jj_consume_token(IDENTIFIER);
    jj_consume_token(TK_SEMI);
      pd.addEntryPoint(new ProgramDecl.EntryPoint(n, w, m));
  }

  final public Token EntryPointName() throws ParseException {
                           Token n;
    n = jj_consume_token(IDENTIFIER);
      {if (true) return n;}
    throw new Error("Missing return statement in function");
  }

  final public void ComponentList(ProgramDecl pd) throws ParseException {
    jj_consume_token(KW_COMPONENTS);
    jj_consume_token(TK_LBRACE);
    ComponentRef(pd);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      jj_consume_token(TK_COMMA);
      ComponentRef(pd);
    }
    jj_consume_token(TK_RBRACE);
  }

  final public void ComponentRef(ProgramDecl pd) throws ParseException {
                                      Token n;
    n = jj_consume_token(IDENTIFIER);
                       pd.addComponent(new ProgramDecl.ComponentRef(n));
  }

  final public VSTTypeDecl TypeDecl(VSTModule m) throws ParseException {
                                      VSTTypeDecl decl;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_CLASS:
      decl = ClassDecl(m);
      break;
    case KW_COMPONENT:
      decl = ComponentDecl(m);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(TK_LBRACE);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_CONSTRUCTOR:
      case KW_FIELD:
      case KW_METHOD:
      case KW_PRIVATE:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_4;
      }
      Member(decl);
    }
    jj_consume_token(TK_RBRACE);
    {if (true) return decl;}
    throw new Error("Missing return statement in function");
  }

  final public VSTClassDecl ClassDecl(VSTModule m) throws ParseException {
  Token tok;
  VSTTypeRef parent = null;
  TypeEnv cenv = new TypeEnv(m.typeEnv);
  List<TypeParam> tpl = null;
    jj_consume_token(KW_CLASS);
    tok = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LT:
      tpl = TypeParamDecl(cenv);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_EXTENDS:
      jj_consume_token(KW_EXTENDS);
      parent = TypeRef();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    {if (true) return new VSTClassDecl(m, tok, tpl, cenv, parent);}
    throw new Error("Missing return statement in function");
  }

  final public VSTComponentDecl ComponentDecl(VSTModule m) throws ParseException {
  Token tok;
    jj_consume_token(KW_COMPONENT);
    tok = jj_consume_token(IDENTIFIER);
    {if (true) return new VSTComponentDecl(m, tok, new TypeEnv(m.typeEnv));}
    throw new Error("Missing return statement in function");
  }

  final public void Member(VSTTypeDecl decl) throws ParseException {
    if (jj_2_1(2147483647)) {
      MethodDecl(decl);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_FIELD:
      case KW_PRIVATE:
        FieldDecl(decl);
        break;
      case KW_CONSTRUCTOR:
        ConstructorDecl(decl);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void MethodDecl(VSTTypeDecl decl) throws ParseException {
  VSTTypeRef ret;
  Token tok;
  VSTMethodDecl m;
  VSTBlock b;
  List<VSTModifier> l;
  List<VSTParamDecl> p;
  List<TypeParam> tpl = null;
  TypeEnv menv = new TypeEnv(decl.typeEnv);
    l = MethodModifiers();
    jj_consume_token(KW_METHOD);
    tok = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LT:
      tpl = TypeParamDecl(menv);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    p = FormalParams();
                       ret = newVoidRef(tok);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_COLON:
      jj_consume_token(TK_COLON);
      ret = TypeRef();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    b = MethodBody();
    m = new VSTMethodDecl(tok, l, tpl, menv, p, ret);
    m.setBlock(b);
    decl.addMethodDecl(m);
  }

  final public List<VSTModifier> MethodModifiers() throws ParseException {
  Token tok;
  List<VSTModifier> l = new LinkedList<VSTModifier>();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_PRIVATE:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
      tok = jj_consume_token(KW_PRIVATE);
                        l.add(new VSTModifier(tok));
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public List<VSTModifier> FieldModifiers() throws ParseException {
  Token tok;
  List<VSTModifier> l = new LinkedList<VSTModifier>();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_PRIVATE:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_6;
      }
      tok = jj_consume_token(KW_PRIVATE);
                        l.add(new VSTModifier(tok));
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public void FieldDecl(VSTTypeDecl decl) throws ParseException {
  VSTTypeRef tref;
  VSTFieldDecl f;
  List<VSTModifier> l;
    l = FieldModifiers();
    jj_consume_token(KW_FIELD);
    oneFieldDecl(decl, l);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_7;
      }
      jj_consume_token(TK_COMMA);
      oneFieldDecl(decl, l);
    }
    jj_consume_token(TK_SEMI);
  }

  final public void ConstructorDecl(VSTTypeDecl decl) throws ParseException {
  Token tok;
  VSTConstructorDecl m;
  List<VSTParamDecl> p;
  VSTBlock b;
  VSTSuperClause sc;
    tok = jj_consume_token(KW_CONSTRUCTOR);
    p = FormalParams();
    sc = SuperClause();
    b = MethodBody();
    m = new VSTConstructorDecl(tok, sc, p);
    m.setBlock(b);
    decl.addConstructor(m);
  }

  final public VSTSuperClause SuperClause() throws ParseException {
  Token tok;
  VSTSuperClause sc = null;
  VSTTupleExpr args;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_COLON:
      jj_consume_token(TK_COLON);
      tok = jj_consume_token(KW_SUPER);
      args = Arguments();
                                           sc = new VSTSuperClause(tok, args);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    {if (true) return sc;}
    throw new Error("Missing return statement in function");
  }

  final public void oneFieldDecl(VSTTypeDecl decl, List<VSTModifier> l) throws ParseException {
  Token tok;
  VSTTypeRef tref;
  Token a = null;
  VSTExpr i = null;
  VSTFieldDecl fd;
    tok = jj_consume_token(IDENTIFIER);
    jj_consume_token(TK_COLON);
    tref = TypeRef();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_ASSIGN:
      a = jj_consume_token(TK_ASSIGN);
      i = Initializer();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    fd = new VSTFieldDecl(tok, false, tref, a, i, l);
    decl.addFieldDecl(fd);
    fd.memberType = tref;
  }

  final public VSTExpr Initializer() throws ParseException {
  VSTExpr i;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LBRACE:
      i = ArrayInitializer();
      break;
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      i = Expr();
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ArrayInitializer() throws ParseException {
  Token tok;
  List<VSTExpr> l = new LinkedList<VSTExpr>();
  VSTExpr e;
    tok = jj_consume_token(TK_LBRACE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_LBRACE:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      InitializerList(l);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(TK_RBRACE);
    {if (true) return new VSTArrayInitializer(tok, l);}
    throw new Error("Missing return statement in function");
  }

  final public void InitializerList(List<VSTExpr> l) throws ParseException {
                                         VSTExpr e;
    e = Initializer();
                       l.add(e);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_8;
      }
      jj_consume_token(TK_COMMA);
      e = Initializer();
                             l.add(e);
    }
  }

  final public List<VSTParamDecl> FormalParams() throws ParseException {
  List<VSTParamDecl> l = new LinkedList<VSTParamDecl>();
  VSTParamDecl p;
    jj_consume_token(TK_LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      p = ParamDecl();
                      l.add(p);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TK_COMMA:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_9;
        }
        jj_consume_token(TK_COMMA);
        p = ParamDecl();
                            l.add(p);
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    jj_consume_token(TK_RPAREN);
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public VSTParamDecl ParamDecl() throws ParseException {
  VSTTypeRef tref;
  Token tok;
    tok = jj_consume_token(IDENTIFIER);
    jj_consume_token(TK_COLON);
    tref = TypeRef();
    {if (true) return new VSTParamDecl(tok, tref);}
    throw new Error("Missing return statement in function");
  }

  final public VSTBlock MethodBody() throws ParseException {
  VSTBlock b;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_SEMI:
      jj_consume_token(TK_SEMI);
          b = null;
      break;
    case TK_LBRACE:
      b = Block();
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  final public VSTBlock Block() throws ParseException {
  Token tok; VSTBlock b;
    tok = jj_consume_token(TK_LBRACE);
              b = new VSTBlock(tok);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_BREAK:
      case KW_CONTINUE:
      case KW_DO:
      case KW_FOR:
      case KW_IF:
      case KW_LOCAL:
      case KW_NEW:
      case KW_RETURN:
      case KW_SWITCH:
      case KW_THIS:
      case KW_WHILE:
      case KW_FALSE:
      case KW_TRUE:
      case KW_NULL:
      case ZERO_LITERAL:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case BIN_LITERAL:
      case OCTAL_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case TK_LPAREN:
      case TK_LBRACE:
      case TK_SEMI:
      case TK_NOT:
      case TK_COMPL:
      case TK_INCDEC:
      case TK_PLUS:
      case TK_MINUS:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_10;
      }
      BlockStmt(b);
    }
    tok = jj_consume_token(TK_RBRACE);
    b.setLastToken(tok);
    {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  final public void BlockStmt(VSTBlock b) throws ParseException {
  VSTStmt s;
    if (jj_2_2(3)) {
      LocalVarDecl(b);
      jj_consume_token(TK_SEMI);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_BREAK:
      case KW_CONTINUE:
      case KW_DO:
      case KW_FOR:
      case KW_IF:
      case KW_NEW:
      case KW_RETURN:
      case KW_SWITCH:
      case KW_THIS:
      case KW_WHILE:
      case KW_FALSE:
      case KW_TRUE:
      case KW_NULL:
      case ZERO_LITERAL:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case BIN_LITERAL:
      case OCTAL_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case TK_LPAREN:
      case TK_LBRACE:
      case TK_SEMI:
      case TK_NOT:
      case TK_COMPL:
      case TK_INCDEC:
      case TK_PLUS:
      case TK_MINUS:
        s = Stmt();
               b.addStmt(s);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void LocalVarDecl(VSTBlock b) throws ParseException {
  VSTTypeRef tref;
  VSTLocalVarDecl s;
    jj_consume_token(KW_LOCAL);
    s = oneLocalVarDecl();
                          b.addStmt(s);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_11;
      }
      jj_consume_token(TK_COMMA);
      s = oneLocalVarDecl();
                                b.addStmt(s);
    }
  }

  final public VSTLocalVarDecl oneLocalVarDecl() throws ParseException {
  Token tok;
  VSTExpr i = null;
  VSTTypeRef tref = null;
    tok = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_COLON:
      jj_consume_token(TK_COLON);
      tref = TypeRef();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_ASSIGN:
      jj_consume_token(TK_ASSIGN);
      i = Initializer();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    {if (true) return new VSTLocalVarDecl(tok, tref, i);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr Expr() throws ParseException {
  VSTExpr e, val;
  Token tok;
    e = ConditionalExpr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_ASSIGN:
    case TK_CASSIGN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_ASSIGN:
        tok = jj_consume_token(TK_ASSIGN);
        val = Expr();
        e = new VSTAssign(tok, e, val);
        break;
      case TK_CASSIGN:
        tok = jj_consume_token(TK_CASSIGN);
        val = Expr();
        e = new VSTCompoundAssign(tok, e, val);
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ConditionalExpr() throws ParseException {
                              Token tok; VSTExpr e, et, ef;
    e = ConditionalOrExpr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 89:
      tok = jj_consume_token(89);
      et = Expr();
      jj_consume_token(TK_COLON);
      ef = ConditionalExpr();
      e = new VSTTernaryExpr(tok, e, et, ef);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ConditionalOrExpr() throws ParseException {
                                VSTExpr e, et; Token tok;
    e = ConditionalAndExpr();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_OR:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_12;
      }
      tok = jj_consume_token(KW_OR);
      et = ConditionalAndExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ConditionalAndExpr() throws ParseException {
                                 VSTExpr e, et; Token tok;
    e = InclusiveOrExpr();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_AND:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_13;
      }
      tok = jj_consume_token(KW_AND);
      et = InclusiveOrExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr InclusiveOrExpr() throws ParseException {
                              VSTExpr e, et; Token tok;
    e = ExclusiveOrExpr();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_OR:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_14;
      }
      tok = jj_consume_token(TK_OR);
      et = ExclusiveOrExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ExclusiveOrExpr() throws ParseException {
                              VSTExpr e, et; Token tok;
    e = AndExpr();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_XOR:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_15;
      }
      tok = jj_consume_token(TK_XOR);
      et = AndExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr AndExpr() throws ParseException {
                      VSTExpr e, et; Token tok;
    e = EqualityExpr();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_AND:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_16;
      }
      tok = jj_consume_token(TK_AND);
      et = EqualityExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr EqualityExpr() throws ParseException {
                           VSTExpr e, et; Token tok;
    e = TypeQueryExpr();
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_EQ:
        ;
        break;
      default:
        jj_la1[36] = jj_gen;
        break label_17;
      }
      tok = jj_consume_token(TK_EQ);
      et = TypeQueryExpr();
      e = new VSTComparison(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr TypeQueryExpr() throws ParseException {
                            Token tok; VSTExpr e; VSTTypeRef tref;
    e = RelationalExpr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_INSTANCEOF:
    case TK_TYPE_QUERY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_INSTANCEOF:
        tok = jj_consume_token(KW_INSTANCEOF);
        break;
      case TK_TYPE_QUERY:
        tok = jj_consume_token(TK_TYPE_QUERY);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      tref = TypeInExpr();
                                                            e = new VSTTypeQueryExpr(tok, e, tref);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr RelationalExpr() throws ParseException {
                             VSTExpr e, et; Token tok;
    e = ConcatExpr();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_LT:
      case TK_GT:
      case TK_LTEQ:
      case TK_GTEQ:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_18;
      }
      tok = RelationalOp();
      et = ConcatExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public Token RelationalOp() throws ParseException {
                         Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LT:
      tok = jj_consume_token(TK_LT);
      break;
    case TK_GT:
      tok = jj_consume_token(TK_GT);
      break;
    case TK_GTEQ:
      tok = jj_consume_token(TK_GTEQ);
      break;
    case TK_LTEQ:
      tok = jj_consume_token(TK_LTEQ);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tok;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ConcatExpr() throws ParseException {
                         VSTExpr e, et; Token tok;
    e = ShiftExpr();
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_HASH:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_19;
      }
      tok = jj_consume_token(TK_HASH);
      et = ShiftExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr ShiftExpr() throws ParseException {
                        VSTExpr e, et; Token tok;
    e = AdditiveExpr();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_SHIFT:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_20;
      }
      tok = jj_consume_token(TK_SHIFT);
      et = AdditiveExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr AdditiveExpr() throws ParseException {
                           VSTExpr e, et; Token tok;
    e = MultiplicativeExpr();
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_PLUS:
      case TK_MINUS:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_21;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_PLUS:
        tok = jj_consume_token(TK_PLUS);
        break;
      case TK_MINUS:
        tok = jj_consume_token(TK_MINUS);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      et = MultiplicativeExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr MultiplicativeExpr() throws ParseException {
                                 VSTExpr e, et; Token tok;
    e = TypeCastExpr();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_MUL:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_22;
      }
      tok = jj_consume_token(TK_MUL);
      et = TypeCastExpr();
      e = new VSTBinOp(tok, e, et);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr TypeCastExpr() throws ParseException {
                           Token tok; VSTExpr e; VSTTypeRef tref;
    e = PostIncDecExpr();
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_TYPE_CAST:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_23;
      }
      tok = jj_consume_token(TK_TYPE_CAST);
      tref = TypeInExpr();
                                     e = new VSTTypeCastExpr(tok, e, tref);
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr PostIncDecExpr() throws ParseException {
                             VSTExpr e; Token tok;
    e = UnaryExpr();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_INCDEC:
      tok = jj_consume_token(TK_INCDEC);
        e = new VSTPostOp(tok, e);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr UnaryExpr() throws ParseException {
                        VSTExpr e, et; Token tok;
    if (jj_2_3(2)) {
      e = NegativeLiteral();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_NOT:
      case TK_COMPL:
      case TK_PLUS:
      case TK_MINUS:
        tok = UnaryOp();
        et = UnaryExpr();
                                       e = new VSTUnaryOp(tok, et);
        break;
      case TK_INCDEC:
        e = PreIncDecExpr();
        break;
      case KW_NEW:
      case KW_THIS:
      case KW_FALSE:
      case KW_TRUE:
      case KW_NULL:
      case ZERO_LITERAL:
      case DECIMAL_LITERAL:
      case HEX_LITERAL:
      case BIN_LITERAL:
      case OCTAL_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case IDENTIFIER:
      case TK_LPAREN:
        e = Term();
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr NegativeLiteral() throws ParseException {
                              Token m, tok;
    m = jj_consume_token(TK_MINUS);
    tok = jj_consume_token(DECIMAL_LITERAL);
      {if (true) return new VSTIntLiteral(m, tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr PreIncDecExpr() throws ParseException {
                            VSTExpr e; Token tok;
    tok = jj_consume_token(TK_INCDEC);
    e = UnaryExpr();
                                      {if (true) return new VSTPreOp(tok, e);}
    throw new Error("Missing return statement in function");
  }

  final public Token UnaryOp() throws ParseException {
                    Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_COMPL:
      tok = jj_consume_token(TK_COMPL);
      break;
    case TK_NOT:
      tok = jj_consume_token(TK_NOT);
      break;
    case TK_PLUS:
      tok = jj_consume_token(TK_PLUS);
      break;
    case TK_MINUS:
      tok = jj_consume_token(TK_MINUS);
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tok;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr Term() throws ParseException {
                   VSTExpr e, et;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
      e = TermPrefix();
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TK_LPAREN:
        case TK_LBRACKET:
        case TK_DOT:
          ;
          break;
        default:
          jj_la1[50] = jj_gen;
          break label_24;
        }
        e = Suffix(e);
      }
      break;
    case KW_NEW:
      e = NewExpr();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TK_LPAREN:
        case TK_DOT:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_25;
        }
        e = NewSuffix(e);
      }
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr Suffix(VSTExpr e) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LPAREN:
    case TK_DOT:
      e = NewSuffix(e);
      break;
    case TK_LBRACKET:
      e = IndexSuffix(e);
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr NewSuffix(VSTExpr e) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_DOT:
      e = MemberSuffix(e);
      break;
    case TK_LPAREN:
      e = AppSuffix(e);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr TermPrefix() throws ParseException {
                         VSTExpr e; Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      e = VarUse();
      break;
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      e = Literal();
      break;
    case TK_LPAREN:
      jj_consume_token(TK_LPAREN);
      e = Expr();
      jj_consume_token(TK_RPAREN);
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr VarUse() throws ParseException {
                     Token tok;
    tok = jj_consume_token(IDENTIFIER);
                       {if (true) return new VSTVarUse(tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr Literal() throws ParseException {
                      VSTExpr e; Token tok;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ZERO_LITERAL:
      tok = jj_consume_token(ZERO_LITERAL);
                         e = new VSTIntLiteral(null, tok);
      break;
    case BIN_LITERAL:
      tok = jj_consume_token(BIN_LITERAL);
                        e = new VSTRawLiteral(tok);
      break;
    case OCTAL_LITERAL:
      tok = jj_consume_token(OCTAL_LITERAL);
                          e = new VSTRawLiteral(tok);
      break;
    case DECIMAL_LITERAL:
      tok = jj_consume_token(DECIMAL_LITERAL);
                            e = new VSTIntLiteral(null, tok);
      break;
    case HEX_LITERAL:
      tok = jj_consume_token(HEX_LITERAL);
                        e = new VSTRawLiteral(tok);
      break;
    case STRING_LITERAL:
      tok = jj_consume_token(STRING_LITERAL);
                           e = new VSTStringLiteral(tok);
      break;
    case CHARACTER_LITERAL:
      tok = jj_consume_token(CHARACTER_LITERAL);
                              e = new VSTCharLiteral(tok);
      break;
    case KW_NULL:
      tok = jj_consume_token(KW_NULL);
                 e = new VSTNullLiteral(tok);
      break;
    case KW_THIS:
      tok = jj_consume_token(KW_THIS);
                 e = new VSTThisLiteral(tok);
      break;
    case KW_TRUE:
      tok = jj_consume_token(KW_TRUE);
                 e = new VSTBoolLiteral(tok);
      break;
    case KW_FALSE:
      tok = jj_consume_token(KW_FALSE);
                  e = new VSTBoolLiteral(tok);
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr NewExpr() throws ParseException {
                      Token tok; VSTExpr e; VSTTypeRef tref;
    tok = jj_consume_token(KW_NEW);
    tref = TypeRef();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LBRACKET:
      e = NewArraySuffix(tok, tref);
      break;
    case TK_LPAREN:
      e = NewObjectSuffix(tok, tref);
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr NewArraySuffix(Token tok, VSTTypeRef tref) throws ParseException {
  List<VSTExpr> l;
    l = ArrayDims();
    {if (true) return new VSTNewArrayExpr(tok, tref, l);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr NewObjectSuffix(Token tok, VSTTypeRef tref) throws ParseException {
  VSTTupleExpr l;
    l = Arguments();
    {if (true) return new VSTNewObjectExpr(tok, tref, l);}
    throw new Error("Missing return statement in function");
  }

  final public List<VSTExpr> ArrayDims() throws ParseException {
  VSTExpr e; List<VSTExpr> l = new LinkedList<VSTExpr>();
    label_26:
    while (true) {
      jj_consume_token(TK_LBRACKET);
      e = Expr();
      jj_consume_token(TK_RBRACKET);
                        l.add(e);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_LBRACKET:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_26;
      }
    }
    {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr MemberSuffix(VSTExpr e) throws ParseException {
                                    List<VSTExpr> l; Token tok;
    jj_consume_token(TK_DOT);
    tok = jj_consume_token(IDENTIFIER);
                           {if (true) return new VSTMemberExpr(tok, e);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr AppSuffix(VSTExpr e) throws ParseException {
  VSTTupleExpr l;
    l = Arguments();
                    {if (true) return new VSTAppExpr(e, l);}
    throw new Error("Missing return statement in function");
  }

  final public VSTExpr IndexSuffix(VSTExpr e) throws ParseException {
                                   Token tok; VSTExpr et; List<VSTExpr> l;
    tok = jj_consume_token(TK_LBRACKET);
    et = Expr();
    jj_consume_token(TK_RBRACKET);
                              {if (true) return new VSTIndexExpr(tok,e,et);}
    throw new Error("Missing return statement in function");
  }

  final public VSTTupleExpr Arguments() throws ParseException {
  Token tok;
  List<VSTExpr> l = new LinkedList<VSTExpr>();
    tok = jj_consume_token(TK_LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      ListExpr(l);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    jj_consume_token(TK_RPAREN);
   {if (true) return new VSTTupleExpr(tok, l);}
    throw new Error("Missing return statement in function");
  }

  final public List<VSTExpr> ListExpr(List<VSTExpr> l) throws ParseException {
  VSTExpr e;
    e = Expr();
               l.add(e);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_27;
      }
      jj_consume_token(TK_COMMA);
      e = Expr();
                     l.add(e);
    }
   {if (true) return l;}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt Stmt() throws ParseException {
                   VSTStmt s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LBRACE:
      s = Block();
      break;
    case TK_SEMI:
      s = EmptyStmt();
      break;
    case KW_BREAK:
      s = BreakStmt();
      break;
    case KW_CONTINUE:
      s = ContinueStmt();
      break;
    case KW_RETURN:
      s = ReturnStmt();
      break;
    case KW_WHILE:
      s = WhileStmt();
      break;
    case KW_FOR:
      s = ForStmt();
      break;
    case KW_IF:
      s = IfStmt();
      break;
    case KW_DO:
      s = DoWhileStmt();
      break;
    case KW_SWITCH:
      s = SwitchStmt();
      break;
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      s = ExprStmt();
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt IfStmt() throws ParseException {
                     Token tok; VSTStmt s, st, sf = null; VSTExpr c;
    tok = jj_consume_token(KW_IF);
    jj_consume_token(TK_LPAREN);
    c = Expr();
    jj_consume_token(TK_RPAREN);
    st = Stmt();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_ELSE:
      jj_consume_token(KW_ELSE);
      sf = Stmt();
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    {if (true) return new VSTIfStmt(tok, c, st, sf);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt SwitchStmt() throws ParseException {
                         Token tok; VSTExpr e; VSTSwitchStmt ss;
    tok = jj_consume_token(KW_SWITCH);
    jj_consume_token(TK_LPAREN);
    e = Expr();
    jj_consume_token(TK_RPAREN);
    jj_consume_token(TK_LBRACE);
     ss = new VSTSwitchStmt(tok, e);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KW_CASE:
      case KW_DEFAULT:
        ;
        break;
      default:
        jj_la1[63] = jj_gen;
        break label_28;
      }
      SwitchCase(ss);
    }
    jj_consume_token(TK_RBRACE);
   {if (true) return ss;}
    throw new Error("Missing return statement in function");
  }

  final public void SwitchCase(VSTSwitchStmt ss) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_CASE:
      ValueCase(ss);
      break;
    case KW_DEFAULT:
      DefaultCase(ss);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ValueCase(VSTSwitchStmt ss) throws ParseException {
                                     Token tok; List<VSTExpr> l = new LinkedList<VSTExpr>(); VSTStmt s;
    tok = jj_consume_token(KW_CASE);
    jj_consume_token(TK_LPAREN);
    ListExpr(l);
    jj_consume_token(TK_RPAREN);
    s = Stmt();
      ss.addCase(new VSTSwitchCase(tok, l, s));
  }

  final public void DefaultCase(VSTSwitchStmt ss) throws ParseException {
                                       Token tok; VSTStmt s;
    tok = jj_consume_token(KW_DEFAULT);
    s = Stmt();
      ss.addDefaultCase(new VSTSwitchCase(tok, null, s));
  }

  final public VSTStmt ForStmt() throws ParseException {
  Token tok;
  List<VSTExpr> i = new LinkedList<VSTExpr>(), u = new LinkedList<VSTExpr>();
  VSTStmt s;
  VSTExpr c = null;
    tok = jj_consume_token(KW_FOR);
    jj_consume_token(TK_LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      ListExpr(i);
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    jj_consume_token(TK_SEMI);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      c = Expr();
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    jj_consume_token(TK_SEMI);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      ListExpr(u);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    jj_consume_token(TK_RPAREN);
    s = Stmt();
    {if (true) return new VSTForStmt(tok, i, c, u, s);}
    throw new Error("Missing return statement in function");
  }

  final public void ExprStmtList(VSTBlock b) throws ParseException {
  VSTStmt s;
    s = ExprStmt();
                   b.addStmt(s);
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_29;
      }
      jj_consume_token(TK_COMMA);
      s = ExprStmt();
                          b.addStmt(s);
    }
  }

  final public VSTStmt ExprStmt() throws ParseException {
                       Token tok; VSTExpr e;
    e = Expr();
    jj_consume_token(TK_SEMI);
    {if (true) return new VSTExprStmt(e.getToken(), e);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt EmptyStmt() throws ParseException {
                        Token tok;
    tok = jj_consume_token(TK_SEMI);
              {if (true) return new VSTEmptyStmt(tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt BreakStmt() throws ParseException {
                        Token tok;
    tok = jj_consume_token(KW_BREAK);
    jj_consume_token(TK_SEMI);
                      {if (true) return new VSTBreakStmt(tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt ContinueStmt() throws ParseException {
                           Token tok;
    tok = jj_consume_token(KW_CONTINUE);
    jj_consume_token(TK_SEMI);
                         {if (true) return new VSTContinueStmt(tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt ReturnStmt() throws ParseException {
                         Token tok; VSTExpr e = null;
    tok = jj_consume_token(KW_RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_NEW:
    case KW_THIS:
    case KW_FALSE:
    case KW_TRUE:
    case KW_NULL:
    case ZERO_LITERAL:
    case DECIMAL_LITERAL:
    case HEX_LITERAL:
    case BIN_LITERAL:
    case OCTAL_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
    case TK_NOT:
    case TK_COMPL:
    case TK_INCDEC:
    case TK_PLUS:
    case TK_MINUS:
      e = Expr();
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    jj_consume_token(TK_SEMI);
                                     {if (true) return new VSTReturnStmt(tok, e);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt WhileStmt() throws ParseException {
                        Token tok; VSTExpr e; VSTStmt s;
    tok = jj_consume_token(KW_WHILE);
    jj_consume_token(TK_LPAREN);
    e = Expr();
    jj_consume_token(TK_RPAREN);
    s = Stmt();
    {if (true) return new VSTWhileStmt(tok, e, s);}
    throw new Error("Missing return statement in function");
  }

  final public VSTStmt DoWhileStmt() throws ParseException {
                          Token tok; VSTExpr e; VSTStmt s;
    tok = jj_consume_token(KW_DO);
    s = Stmt();
    jj_consume_token(KW_WHILE);
    jj_consume_token(TK_LPAREN);
    e = Expr();
    jj_consume_token(TK_RPAREN);
    jj_consume_token(TK_SEMI);
    {if (true) return new VSTDoWhileStmt(tok, e, s);}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef TypeRef() throws ParseException {
  Token tok;
  VSTTypeRef tref;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_LPAREN:
      tref = NestedType();
      break;
    default:
      jj_la1[70] = jj_gen;
      if (jj_2_4(2)) {
        tref = ParameterizedType();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECIMAL_LITERAL:
        case IDENTIFIER:
          tref = SimpleType();
          break;
        case KW_FUNCTION:
          tref = FuncType();
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    label_30:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_30;
      }
      tok = jj_consume_token(TK_LBRACKET);
      jj_consume_token(TK_RBRACKET);
                                  tref = newArrayTypeRef(tok, tref);
    }
   {if (true) return tref;}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef NestedType() throws ParseException {
                            VSTTypeRef tref;
    jj_consume_token(TK_LPAREN);
    tref = TypeRef();
    jj_consume_token(TK_RPAREN);
                               {if (true) return tref;}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef FuncType() throws ParseException {
  VSTTypeRef rt = null;
  List<VSTTypeRef> l = new LinkedList<VSTTypeRef>();
  Token tok;
    tok = jj_consume_token(KW_FUNCTION);
    jj_consume_token(TK_LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case KW_FUNCTION:
    case DECIMAL_LITERAL:
    case IDENTIFIER:
    case TK_LPAREN:
      TypeList(l);
      break;
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    jj_consume_token(TK_RPAREN);
                            rt = newVoidRef(tok);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_COLON:
      jj_consume_token(TK_COLON);
      rt = TypeRef();
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    {if (true) return newFuncTypeRef(tok, rt, l);}
    throw new Error("Missing return statement in function");
  }

  final public List<TypeParam> TypeParamDecl(TypeEnv env) throws ParseException {
   List<TypeParam> tpl = new LinkedList<TypeParam>();
    jj_consume_token(TK_LT);
    TypeParam(env, tpl);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_31;
      }
      jj_consume_token(TK_COMMA);
      TypeParam(env, tpl);
    }
    jj_consume_token(TK_GT);
                                                              {if (true) return tpl;}
    throw new Error("Missing return statement in function");
  }

  final public void TypeParam(TypeEnv nenv, List<TypeParam> tp) throws ParseException {
   Token tok;
    tok = jj_consume_token(IDENTIFIER);
                        addTypeParam(tok, nenv, tp);
  }

  final public VSTTypeRef ParameterizedType() throws ParseException {
  Token tycon;
  List<VSTTypeRef> l = new LinkedList<VSTTypeRef>();
    tycon = jj_consume_token(IDENTIFIER);
    jj_consume_token(TK_LT);
    TypeList(l);
    jj_consume_token(TK_GT);
     {if (true) return newParamTypeRef(tycon, l);}
    throw new Error("Missing return statement in function");
  }

  final public void TypeList(List<VSTTypeRef> l) throws ParseException {
  VSTTypeRef tref;
    tref = TypeRef();
                       l.add(tref);
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_COMMA:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_32;
      }
      jj_consume_token(TK_COMMA);
      tref = TypeRef();
                             l.add(tref);
    }
  }

  final public VSTTypeRef TypeInExpr() throws ParseException {
  VSTTypeRef tr;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
    case IDENTIFIER:
      tr = SimpleType();
      break;
    case TK_LPAREN:
      tr = NestedType();
      break;
    default:
      jj_la1[76] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tr;}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef SimpleType() throws ParseException {
  VSTTypeRef tr;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tr = SingularType();
      break;
    case DECIMAL_LITERAL:
      tr = RawType();
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tr;}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef SingularType() throws ParseException {
  Token tok;
    tok = jj_consume_token(IDENTIFIER);
                       {if (true) return newTypeRef(tok);}
    throw new Error("Missing return statement in function");
  }

  final public VSTTypeRef RawType() throws ParseException {
  Token tok;
    tok = jj_consume_token(DECIMAL_LITERAL);
                            {if (true) return newTypeRef(tok);}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(TK_COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(TK_MINUS)) return true;
    if (jj_scan_token(DECIMAL_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(KW_LOCAL)) return true;
    if (jj_3R_38()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(KW_PRIVATE)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_37()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(TK_ASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(TK_COLON)) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_35()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(KW_METHOD)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_40()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_34()) return true;
    if (jj_scan_token(TK_SEMI)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(TK_LBRACKET)) return true;
    if (jj_scan_token(TK_RBRACKET)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(TK_LT)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_36()) return true;
    return false;
  }

  public VirgilParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[78];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x30000,0x0,0x0,0x0,0x30000,0x81040000,0x0,0x800000,0x1040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x52284000,0x12284000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x12284000,0x400000,0x108000,0x108000,0x0,0x0,0x0,0x0,0x0,0x0,0x4000000,0x4000000,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x100,0x0,0x3000,0x3000,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x29ffc041,0x29ffc041,0x0,0x0,0x1000000,0x20000000,0x29ffc0e9,0x29ffc0e9,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9ffc041,0x0,0x88000000,0x8000000,0x9ffc041,0x88000000,0x8000000,0x9ffc040,0xffc040,0x88000000,0x80000000,0x9ffc041,0x0,0x29ffc0e9,0x0,0x0,0x0,0x9ffc041,0x9ffc041,0x9ffc041,0x0,0x9ffc041,0x8000000,0x1040000,0x9040000,0x0,0x0,0x0,0x9040000,0x1040000,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x20,0x0,0x0,0x20,0x800,0x0,0x0,0x4,0x800,0x10,0x38600,0x38600,0x4,0x4,0x0,0x2,0x38602,0x38602,0x4,0x800,0x10,0x1000010,0x1000010,0x2000000,0x0,0x0,0x100000,0x200000,0x80000,0x4000,0x1000,0x1000,0x1e0,0x1e0,0x800000,0x400000,0x30000,0x30000,0x40000,0x2000,0x8000,0x38600,0x30600,0x8,0x8,0x0,0x8,0x8,0x0,0x0,0x0,0x0,0x38600,0x4,0x38602,0x0,0x0,0x0,0x38600,0x38600,0x38600,0x4,0x38600,0x0,0x0,0x0,0x800,0x4,0x4,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[5];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

    public VirgilParser(VirgilParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(VirgilParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 78; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[90];
    for (int i = 0; i < 90; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 78; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 90; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 5; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
