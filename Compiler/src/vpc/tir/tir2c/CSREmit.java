/**
 * Copyright (c) 2006, Regents of the University of California
 * See the file "license.txt" for details.
 *
 * Creation date: Jan 26, 2006
 */

package vpc.tir.tir2c;

import cck.text.Printer;
import cck.text.StringUtil;
import cck.util.ClassMap;
import cck.util.Option;
import vpc.Version;
import vpc.core.Program;
import vpc.core.Value;
import vpc.core.csr.*;
import vpc.core.decl.Method;
import vpc.sched.Stage;
import vpc.tir.TIRUtil;
import vpc.util.Ovid;

import java.io.*;
import java.util.*;

/**
 * The <code>TIREmitC</code> class implements a compiler stage that generates C code
 * from TIR.
 *
 * @author Ben L. Titzer
 */
public class CSREmit extends Stage {

    protected static final ClassMap linkageMap = new ClassMap("Linkage Model", CLinkage.class);

    static {
        linkageMap.addClass("c:test", CLinkage.CTestLinkage.class);
        linkageMap.addClass("c:avr", CLinkage.CAVRLinkage.class);
        linkageMap.addClass("c:avrora", CLinkage.CAvroraTestLinkage.class);
        linkageMap.addClass("c:user", CLinkage.CUserLinkage.class);
    }

    protected Option.Str LINKAGE = options.newOption("linkage", "c:user",
            "This option selects the linkage model for emitting C code that can be compiled " +
            "by the appropriate platform C compiler. For example, the linkage model selects " +
            "what version of the \"main\" method will be generated and how other entrypoints " +
            "to the program will be connected with generate C glue code.");

    public void visitProgram(Program p) throws IOException {
        Printer pr = new Printer(new PrintStream(new FileOutputStream(p.name + ".c")));
        new Generator(p, pr).generate();
    }

    protected class Generator {
        protected final Program program;
        protected final CSRProgram csr;
        protected final Printer printer;

        Generator(Program p, Printer pr) {
            program = p;
            csr = p.csr;
            printer = pr;
        }


        void generate() {
            // generate the header comment
            generateHeader();
            // make some safety check functions
            generateIncludes();
            // make some safety check functions
            csr.makeSafetyChecks();
            // generate main method and interrupt handlers
            CLinkage linkage = (CLinkage) linkageMap.getObjectOfClass(LINKAGE.get());
            linkage.generateLinkage(program);
            // compile Virgil methods
            compileMethods();
            // declare and define all structs
            declareStructures();
            // declare prototypes for all functions
            declareFunctions();
            // emit the heap object definitions
            defineHeap();
            // emit the code for each function
            defineFunctions();
        }

        void generateHeader() {
            printer.println("//==========================================================");
            printer.println("// C code generated by: VPC [" + Version.getVersion() + "]");
            printer.println("// " + new Date());
            printer.println("//==========================================================");
            printer.println("");
        }

        void generateIncludes() {
            for ( String s : csr.includes ) {
                printer.println("#include <"+s+">");
            }
        }

        void declareStructures() {
            printSeparator("Struct definitions");
            LinkedList<CSRStruct.IType> structs = reorderStructs();
            for (CSRStruct.IType st : structs) declareStructure(st);
            for (CSRStruct.IType st : structs) defineStructure(st);
            printer.println("");
        }

        LinkedList<CSRStruct.IType> reorderStructs() {
            LinkedList<CSRStruct.IType> list = Ovid.newLinkedList();
            Set<CSRStruct.IType> set = Ovid.newSet();
            for (CSRStruct.IType st : csr.structs) {
                addStruct(st, set, list);
            }
            return list;
        }

        void addStruct(CSRStruct.IType stype, Set<CSRStruct.IType> set, LinkedList<CSRStruct.IType> list) {
            if (set.contains(stype)) return;
            set.add(stype);
            for (CSRStruct.IType.Field field : stype.fields) {
                if (field.type instanceof CSRStruct.IType) 
                    addStruct((CSRStruct.IType)field.type, set, list);
            }
            list.add(stype);
        }

        void printSeparator(String title) {
            printer.print("//=========={ ");
            printer.print(title);
            printer.print(" }");
            printer.println(StringUtil.dup('=', 65 - title.length()));
        }

        void compileMethods() {
            // declare all the component methods
            for (Method m : program.closure.methods) {
                CSRFunction cf = new CSRFunction(csr, m);
                cf.addParams(csr, TIRUtil.getRep(m).getParams());
                new TIRCompiler(csr).compile(cf);
                csr.functions.add(cf);
            }
        }

        void declareFunctions() {
            printSeparator("Function prototypes");
            for (CSRFunction cf : csr.functions) cf.printPrototype(printer);
            printer.println("");
        }

        void defineHeap() {
            // declare each global variable
            printSeparator("Global data declarations");
            for ( CSRData.Global g : csr.globals ) declareGlobal(g);
            printer.println("");
            // emit the definition of each global variable
            printSeparator("Global data definitions");
            for ( CSRData.Global g : csr.globals ) defineGlobal(g);
            printer.println("");
        }

        void declareGlobal(CSRData.Global global) {
            printer.print(global.type.globalDecl(global.name));
            printAttributes(global);
            printer.println(";");
        }

        private void printAttributes(CSRData.Global global) {
            for ( String s : global.attributes ) {
                printer.print(" __attribute__((");
                printer.print(s);
                printer.print("))");
            }
        }

        void defineGlobal(CSRData.Global global) {
            CSRType gt = global.type;
            Value gv = global.value;
            printer.print(gt.globalDecl(global.name));
            printAttributes(global);
            printer.print(" = ");
            if ( gt instanceof CSRStruct.IType ) {
                renderStruct(gv, (CSRStruct.IType)gt);
            } else {
                printer.println(gt.renderValue(true, gv) +";");
            }
        }

        void renderStruct(Value gv, CSRStruct.IType gt) {
            printer.startblock();
            Value[] vals = ((CSRStruct.Val) gv).values;
            for ( int cntr = 0; cntr < vals.length; cntr++ ) {
                printer.print(gt.fields.get(cntr).type.renderValue(true, vals[cntr]));
                if ( cntr < vals.length - 1 ) printer.print(",");
                printer.nextln();
            }
            printer.endblock(";");
        }

        void defineFunctions() {
            printSeparator("C functions implementing methods");
            for (CSRFunction cf : csr.functions) {
                // emit C code
                cf.print(printer);
            }
            printer.println("");
        }

        void declareStructure(CSRStruct.IType st) {
            printer.println(st.toString() + ";");
        }

        void defineStructure(CSRStruct.IType st) {
            printer.startblock(st.toString());
            for (CSRStruct.IType.Field f : st.fields)
                printer.println(f.type.fieldDecl(f.name) + ";");
            printer.endblock(";");
        }

    }
}
